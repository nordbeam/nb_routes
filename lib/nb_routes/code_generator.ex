defmodule NbRoutes.CodeGenerator do
  @moduledoc """
  Generates JavaScript code for route helpers.
  """

  alias NbRoutes.{Configuration, Route, Serializer}

  @runtime_file Path.join(:code.priv_dir(:nb_routes), "nb_routes/runtime.js")

  @doc """
  Generates JavaScript code for the given routes.
  """
  def generate(routes, %Configuration{} = config) do
    runtime = load_runtime()

    parts = [
      generate_header(config),
      "",
      generate_runtime(runtime, config),
      "",
      generate_builder(config),
      "",
      generate_routes(routes, config)
    ]

    # Add Inertia helpers for rich mode
    parts =
      if config.variant == :rich do
        parts ++ ["", generate_inertia_helpers()]
      else
        parts
      end

    parts =
      parts ++ ["", generate_exports(config)]

    Enum.join(parts, "\n")
  end

  # Private functions

  defp load_runtime do
    File.read!(@runtime_file)
  end

  defp generate_header(config) do
    """
    /**
     * Generated route helpers
     * Generated by NbRoutes
     *#{if config.documentation, do: generate_documentation(), else: ""}
     * @warning DO NOT EDIT - This file is auto-generated
     */
    """
    |> String.trim()
  end

  defp generate_documentation do
    """

     *
     * Route helpers provide type-safe URL generation for your Phoenix routes.
     *
     * Usage:
     *   import { users_path, user_path } from './routes';
     *
     *   users_path()                    // => "/users"
     *   user_path(1)                    // => "/users/1"
     *   user_path(1, { format: 'json' }) // => "/users/1.json"
    """
  end

  defp generate_runtime(runtime, config) do
    base_runtime =
      case config.module_type do
        :esm ->
          # For ESM, we inline the RouteBuilder class without module exports
          runtime
          |> String.replace(~r/\/\/ Export for different module systems.*$/s, "")
          |> String.trim()

        _ ->
          runtime
      end

    # Add _buildUrl helper for rich mode
    runtime_with_build_url =
      if config.variant == :rich do
        base_runtime <> "\n\n" <> generate_build_url_helper()
      else
        base_runtime
      end

    # Add _buildFormAction helper for forms
    if config.with_forms && config.variant == :rich do
      runtime_with_build_url <> "\n\n" <> generate_build_form_action_helper()
    else
      runtime_with_build_url
    end
  end

  defp generate_build_url_helper do
    """
    /**
     * Build URL from pattern and params (for rich mode)
     * @param {string} pattern - URL pattern with :param placeholders (e.g., "/users/:id")
     * @param {Object} params - Parameter values (e.g., { id: 1 })
     * @param {Object} options - URL options (query, mergeQuery, anchor)
     * @returns {string} Built URL
     */
    function _buildUrl(pattern, params = {}, options = {}) {
      let url = pattern;

      // Replace :param placeholders
      Object.keys(params).forEach(key => {
        const value = params[key];
        if (value !== undefined && value !== null) {
          url = url.replace(new RegExp(':' + key + '(\\\\W|$)', 'g'), encodeURIComponent(String(value)) + '$1');
        }
      });

      // Handle query parameters
      const queryParams = [];

      if (options.query) {
        Object.keys(options.query).forEach(key => {
          const value = options.query[key];
          if (value !== undefined && value !== null) {
            queryParams.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(value)));
          }
        });
      }

      if (options.mergeQuery) {
        Object.keys(options.mergeQuery).forEach(key => {
          const value = options.mergeQuery[key];
          if (value !== undefined && value !== null) {
            queryParams.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(value)));
          } else if (value === null) {
            // null explicitly removes the param (useful for overriding)
            // Skip it
          }
        });
      }

      if (queryParams.length > 0) {
        url += (url.includes('?') ? '&' : '?') + queryParams.join('&');
      }

      // Handle anchor
      if (options.anchor) {
        url += '#' + encodeURIComponent(options.anchor);
      }

      return url;
    }
    """
    |> String.trim()
  end

  defp generate_build_form_action_helper do
    """
    /**
     * Build form action URL with method spoofing (for forms)
     *
     * HTML forms only support GET and POST methods. For other HTTP methods (PATCH, PUT, DELETE),
     * we use POST with a _method parameter that Phoenix's method override plug can handle.
     *
     * @param {string} pattern - URL pattern with :param placeholders (e.g., "/users/:id")
     * @param {Object} params - Parameter values (e.g., { id: 1 })
     * @param {string} method - HTTP method (get, post, patch, put, delete, head, options)
     * @param {Object} options - URL options (query, mergeQuery, anchor)
     * @returns {string} Form action URL with method spoofing if needed
     *
     * @example
     * _buildFormAction("/users/:id", { id: 123 }, "patch", {})
     * // => "/users/123?_method=PATCH"
     *
     * @example
     * _buildFormAction("/users/:id", { id: 123 }, "delete", { query: { confirm: true } })
     * // => "/users/123?confirm=true&_method=DELETE"
     */
    function _buildFormAction(pattern, params = {}, method = 'post', options = {}) {
      // Build the base URL
      let url = _buildUrl(pattern, params, options);

      // Normalize method to lowercase
      const normalizedMethod = method.toLowerCase();

      // Method spoofing for non-GET/POST methods
      // HTML forms only support GET and POST, so we use POST with _method parameter
      if (!['get', 'post'].includes(normalizedMethod)) {
        const separator = url.includes('?') ? '&' : '?';
        url += separator + '_method=' + method.toUpperCase();
      }

      return url;
    }
    """
    |> String.trim()
  end

  defp generate_builder(config) do
    default_url_options = inspect_js_object(config.default_url_options)

    """
    const _builder = new RouteBuilder({
      defaultUrlOptions: #{default_url_options},
      trailingSlash: false
    });
    """
    |> String.trim()
  end

  defp generate_routes(routes, config) do
    routes
    |> Enum.map(&generate_route(&1, config))
    |> Enum.join("\n\n")
  end

  defp generate_route(%Route{} = route, config) do
    params = Serializer.serialize_params(route)
    spec = Serializer.serialize(route)

    [
      generate_route_doc(route, config),
      generate_route_helper(route, params, spec, false, config)
    ]
    |> Enum.reject(&is_nil/1)
    |> Enum.join("\n")
  end

  defp generate_route_doc(%Route{} = route, %Configuration{documentation: true}) do
    param_docs =
      if Enum.empty?(route.required_params) do
        " * @param {Object} [options] - Optional parameters and query string values"
      else
        required_docs =
          Enum.map_join(route.required_params, "\n", fn param ->
            " * @param {string|number} #{param} - Required parameter"
          end)

        required_docs <>
          "\n * @param {Object} [options] - Optional parameters and query string values"
      end

    """
    /**
     * Route: #{route.verb} #{route.path}
     * Helper: #{route.name}
     *
    #{param_docs}
     * @returns {string} The generated path
     *
     * @example
     * #{generate_example(route)}
     */
    """
    |> String.trim()
  end

  defp generate_route_doc(_route, _config), do: nil

  defp generate_example(%Route{required_params: []} = route) do
    "#{route.name}() // => #{example_path(route, [])}"
  end

  defp generate_example(%Route{required_params: params} = route) do
    example_values = Enum.map(params, fn _ -> "1" end)

    "#{route.name}(#{Enum.join(example_values, ", ")}) // => #{example_path(route, example_values)}"
  end

  defp example_path(route, values) do
    # Build path by replacing each parameter
    path =
      route.required_params
      |> Enum.with_index()
      |> Enum.reduce(route.path, fn {param, idx}, acc ->
        value = Enum.at(values, idx, "1") || "1"
        String.replace(acc, ":#{param}", to_string(value))
      end)

    # Remove optional segments
    path
    |> String.replace(~r/\([^)]*\)/, "")
  end

  defp generate_route_helper(route, params, spec, absolute, config) do
    case config.variant do
      :simple ->
        generate_simple_route_helper(route, params, spec, absolute)

      :rich ->
        generate_rich_route_helper(route, params, spec, absolute, config)
    end
  end

  defp generate_simple_route_helper(route, params, spec, absolute) do
    params_js = inspect_js_object(params)
    spec_js = inspect_js(spec)

    case route do
      %Route{name: name} ->
        """
        const #{name} = /*#__PURE__*/ _builder.route(
          #{params_js},
          #{spec_js},
          #{absolute}
        );
        """
        |> String.trim()
    end
  end

  defp generate_rich_route_helper(route, _params, _spec, _absolute, config) do
    # Extract parameter names for function signature
    params_list = Enum.join(route.required_params, ", ")

    # Build JavaScript params object: { id, name }
    params_obj = build_params_object(route.required_params)

    # Get the HTTP method as lowercase string
    method = route.verb |> to_string() |> String.downcase()

    # Generate the main function
    main_fn = generate_route_function(route.name, params_list, route.path, params_obj, method)

    # Generate method variants if enabled
    method_variants =
      if config.with_methods do
        generate_method_variants(route.name, params_list, route.path, params_obj, method)
      else
        "{}"
      end

    # Generate form variants if enabled and route is mutation
    form_variants =
      if config.with_forms && is_mutation_route?(method) do
        generate_form_variants(params_list, route.path, params_obj, method)
      else
        nil
      end

    # Combine variants
    all_variants =
      if form_variants do
        merge_variants(method_variants, form_variants)
      else
        method_variants
      end

    """
    const #{route.name} = Object.assign(
      #{indent(main_fn, 2)},
      #{indent(all_variants, 2)}
    );
    """
    |> String.trim()
  end

  defp build_params_object([]), do: "{}"

  defp build_params_object(params) do
    param_pairs = Enum.map_join(params, ", ", fn p -> p end)
    "{ #{param_pairs} }"
  end

  defp generate_route_function(_route_name, params_list, path, params_obj, method) do
    fn_params = if params_list == "", do: "options", else: "#{params_list}, options"

    """
    function(#{fn_params}) {
      return {
        url: _buildUrl("#{path}", #{params_obj}, options),
        method: "#{method}"
      };
    }
    """
    |> String.trim()
  end

  defp generate_method_variants(_route_name, params_list, path, params_obj, original_method) do
    fn_params = if params_list == "", do: "options", else: "#{params_list}, options"

    # Generate .get, .post, .head, .url variants
    variants = [
      # .get variant
      """
      get: function(#{fn_params}) {
        return {
          url: _buildUrl("#{path}", #{params_obj}, options),
          method: "get"
        };
      }
      """,
      # .head variant
      """
      head: function(#{fn_params}) {
        return {
          url: _buildUrl("#{path}", #{params_obj}, options),
          method: "head"
        };
      }
      """,
      # .url variant (returns just the URL string)
      """
      url: function(#{fn_params}) {
        return _buildUrl("#{path}", #{params_obj}, options);
      }
      """
    ]

    # Add method-specific variant if not already covered
    method_variant =
      case original_method do
        m when m in ["get", "head"] ->
          nil

        m ->
          """
          #{m}: function(#{fn_params}) {
            return {
              url: _buildUrl("#{path}", #{params_obj}, options),
              method: "#{m}"
            };
          }
          """
      end

    all_variants = if method_variant, do: [method_variant | variants], else: variants

    """
    {
      #{Enum.map_join(all_variants, ",\n", &String.trim/1) |> indent(2)}
    }
    """
    |> String.trim()
  end

  defp is_mutation_route?(method) do
    method in ["post", "patch", "put", "delete"]
  end

  defp generate_form_variants(params_list, path, params_obj, original_method) do
    fn_params = if params_list == "", do: "options", else: "#{params_list}, options"

    # Main .form function
    form_main = """
    function(#{fn_params}) {
      return {
        action: _buildFormAction("#{path}", #{params_obj}, "#{original_method}", options),
        method: "post"
      };
    }
    """

    # Method-specific form variants (always POST, PATCH, PUT, DELETE)
    form_method_variants = [
      """
      patch: function(#{fn_params}) {
        return {
          action: _buildFormAction("#{path}", #{params_obj}, "patch", options),
          method: "post"
        };
      }
      """,
      """
      put: function(#{fn_params}) {
        return {
          action: _buildFormAction("#{path}", #{params_obj}, "put", options),
          method: "post"
        };
      }
      """,
      """
      delete: function(#{fn_params}) {
        return {
          action: _buildFormAction("#{path}", #{params_obj}, "delete", options),
          method: "post"
        };
      }
      """
    ]

    # Combine into .form object
    """
    form: Object.assign(
      #{indent(form_main, 2)},
      {
        #{Enum.map_join(form_method_variants, ",\n", &String.trim/1) |> indent(4)}
      }
    )
    """
    |> String.trim()
  end

  defp merge_variants(method_variants, form_variants) do
    # Remove the closing brace from method_variants and add form_variants
    method_variants
    |> String.trim_trailing()
    |> String.trim_trailing("}")
    |> Kernel.<>(",\n  #{form_variants}\n}")
  end

  defp indent(text, spaces) do
    padding = String.duplicate(" ", spaces)

    text
    |> String.split("\n")
    |> Enum.map(fn line ->
      if String.trim(line) == "", do: line, else: padding <> line
    end)
    |> Enum.join("\n")
  end

  defp generate_inertia_helpers do
    """
    /**
     * Inertia.js helper functions for rich mode routes
     */

    /**
     * Visit a route using Inertia.js router
     * @param {Object} route - Route result from a rich mode helper (e.g., users_path())
     * @param {Object} options - Inertia visit options (data, headers, preserveScroll, etc.)
     * @returns {Promise} Inertia visit promise
     *
     * @example
     * import { router } from '@inertiajs/react';
     * import { users_path, visitRoute } from './routes';
     *
     * // Instead of:
     * const route = users_path();
     * router.visit(route.url, { method: route.method });
     *
     * // You can use:
     * visitRoute(users_path());
     *
     * // With additional options:
     * visitRoute(update_user_path.patch(user.id), {
     *   data: formData,
     *   preserveScroll: true
     * });
     */
    function visitRoute(route, options = {}) {
      if (typeof window === 'undefined') {
        throw new Error('visitRoute can only be called in the browser');
      }

      // Check if Inertia router is available
      const inertia = window.Inertia;
      if (!inertia || !inertia.visit) {
        throw new Error(
          'Inertia.js not found. Make sure @inertiajs/inertia is installed and loaded. ' +
          'Visit https://inertiajs.com for setup instructions.'
        );
      }

      // Merge route method with visit options
      return inertia.visit(route.url, {
        method: route.method,
        ...options
      });
    }
    """
  end

  defp generate_exports(%Configuration{module_type: :esm, variant: :rich}) do
    """
    // Configuration functions
    export const configure = (options) => _builder.configure(options);
    export const config = () => _builder.getConfig();
    export { _buildUrl, visitRoute };
    """
  end

  defp generate_exports(%Configuration{module_type: :esm}) do
    """
    // Configuration functions
    export const configure = (options) => _builder.configure(options);
    export const config = () => _builder.getConfig();
    """
  end

  defp generate_exports(%Configuration{module_type: :cjs, variant: :rich}) do
    """
    // Configuration functions
    module.exports.configure = (options) => _builder.configure(options);
    module.exports.config = () => _builder.getConfig();
    module.exports._buildUrl = _buildUrl;
    module.exports.visitRoute = visitRoute;
    """
  end

  defp generate_exports(%Configuration{module_type: :cjs}) do
    """
    // Configuration functions
    module.exports.configure = (options) => _builder.configure(options);
    module.exports.config = () => _builder.getConfig();
    """
  end

  defp generate_exports(%Configuration{module_type: :umd, variant: :rich}) do
    # UMD exports both CommonJS and AMD style
    """
    // Configuration functions
    const configure = (options) => _builder.configure(options);
    const config = () => _builder.getConfig();

    if (typeof module !== 'undefined' && module.exports) {
      module.exports = { configure, config, _buildUrl, visitRoute };
    } else if (typeof define === 'function' && define.amd) {
      define([], function() { return { configure, config, _buildUrl, visitRoute }; });
    } else {
      this.Routes = this.Routes || {};
      this.Routes.configure = configure;
      this.Routes.config = config;
      this.Routes._buildUrl = _buildUrl;
      this.Routes.visitRoute = visitRoute;
    }
    """
  end

  defp generate_exports(%Configuration{module_type: :umd}) do
    # UMD exports both CommonJS and AMD style
    """
    // Configuration functions
    const configure = (options) => _builder.configure(options);
    const config = () => _builder.getConfig();

    if (typeof module !== 'undefined' && module.exports) {
      module.exports = { configure, config };
    } else if (typeof define === 'function' && define.amd) {
      define([], function() { return { configure, config }; });
    } else {
      this.Routes = this.Routes || {};
      this.Routes.configure = configure;
      this.Routes.config = config;
    }
    """
  end

  defp generate_exports(%Configuration{module_type: nil, variant: :rich}) do
    # Global namespace
    """
    // Configuration functions
    window.Routes = window.Routes || {};
    window.Routes.configure = (options) => _builder.configure(options);
    window.Routes.config = () => _builder.getConfig();
    window.Routes._buildUrl = _buildUrl;
    window.Routes.visitRoute = visitRoute;
    """
  end

  defp generate_exports(%Configuration{module_type: nil}) do
    # Global namespace
    """
    // Configuration functions
    window.Routes = window.Routes || {};
    window.Routes.configure = (options) => _builder.configure(options);
    window.Routes.config = () => _builder.getConfig();
    """
  end

  # Helper to convert Elixir data to JavaScript object notation
  defp inspect_js(data) when is_list(data) do
    items = Enum.map_join(data, ", ", &inspect_js/1)
    "[#{items}]"
  end

  defp inspect_js(data) when is_map(data) do
    inspect_js_object(data)
  end

  defp inspect_js(data) when is_binary(data) do
    # Escape quotes and wrap in quotes
    escaped = String.replace(data, "\"", "\\\"")
    "\"#{escaped}\""
  end

  defp inspect_js(data) when is_atom(data) do
    "\"#{data}\""
  end

  defp inspect_js(data) when is_number(data) or is_boolean(data) do
    to_string(data)
  end

  defp inspect_js(nil), do: "null"
  defp inspect_js(data), do: inspect(data)

  defp inspect_js_object(map) when is_map(map) do
    if map_size(map) == 0 do
      "{}"
    else
      pairs =
        map
        |> Enum.map(fn {k, v} ->
          key = if is_atom(k), do: Atom.to_string(k), else: k
          "#{key}: #{inspect_js(v)}"
        end)
        |> Enum.join(", ")

      "{ #{pairs} }"
    end
  end
end
