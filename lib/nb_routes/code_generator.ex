defmodule NbRoutes.CodeGenerator do
  @moduledoc """
  Generates JavaScript code for route helpers.
  """

  alias NbRoutes.{Configuration, Route, Serializer}

  @runtime_file Path.join(:code.priv_dir(:nb_routes), "nb_routes/runtime.js")

  @doc """
  Generates JavaScript code for the given routes.

  ## Examples

      iex> routes = [%NbRoutes.Route{name: "user_path", ...}]
      iex> NbRoutes.CodeGenerator.generate(routes, %NbRoutes.Configuration{})
      "export const user_path = ..."

  """
  def generate(routes, %Configuration{} = config) do
    runtime = load_runtime()

    [
      generate_header(config),
      "",
      generate_runtime(runtime, config),
      "",
      generate_builder(config),
      "",
      generate_routes(routes, config),
      "",
      generate_exports(config)
    ]
    |> Enum.join("\n")
  end

  # Private functions

  defp load_runtime do
    File.read!(@runtime_file)
  end

  defp generate_header(config) do
    """
    /**
     * Generated route helpers
     * Generated by NbRoutes
     *#{if config.documentation, do: generate_documentation(), else: ""}
     * @warning DO NOT EDIT - This file is auto-generated
     */
    """
    |> String.trim()
  end

  defp generate_documentation do
    """

     *
     * Route helpers provide type-safe URL generation for your Phoenix routes.
     *
     * Usage:
     *   import { users_path, user_path } from './routes';
     *
     *   users_path()                    // => "/users"
     *   user_path(1)                    // => "/users/1"
     *   user_path(1, { format: 'json' }) // => "/users/1.json"
    """
  end

  defp generate_runtime(runtime, config) do
    case config.module_type do
      :esm ->
        # For ESM, we inline the RouteBuilder class without module exports
        runtime
        |> String.replace(~r/\/\/ Export for different module systems.*$/s, "")
        |> String.trim()

      _ ->
        runtime
    end
  end

  defp generate_builder(config) do
    default_url_options = inspect_js_object(config.default_url_options)

    """
    const _builder = new RouteBuilder({
      defaultUrlOptions: #{default_url_options},
      trailingSlash: false
    });
    """
    |> String.trim()
  end

  defp generate_routes(routes, config) do
    routes
    |> Enum.map(&generate_route(&1, config))
    |> Enum.join("\n\n")
  end

  defp generate_route(%Route{} = route, config) do
    params = Serializer.serialize_params(route)
    spec = Serializer.serialize(route)

    [
      generate_route_doc(route, config),
      generate_route_helper(route, params, spec, false)
    ]
    |> Enum.reject(&is_nil/1)
    |> Enum.join("\n")
  end

  defp generate_route_doc(%Route{} = route, %Configuration{documentation: true}) do
    param_docs =
      if Enum.empty?(route.required_params) do
        " * @param {Object} [options] - Optional parameters and query string values"
      else
        required_docs =
          Enum.map_join(route.required_params, "\n", fn param ->
            " * @param {string|number} #{param} - Required parameter"
          end)

        required_docs <>
          "\n * @param {Object} [options] - Optional parameters and query string values"
      end

    """
    /**
     * Route: #{route.verb} #{route.path}
     * Helper: #{route.name}
     *
    #{param_docs}
     * @returns {string} The generated path
     *
     * @example
     * #{generate_example(route)}
     */
    """
    |> String.trim()
  end

  defp generate_route_doc(_route, _config), do: nil

  defp generate_example(%Route{required_params: []} = route) do
    "#{route.name}() // => #{example_path(route, [])}"
  end

  defp generate_example(%Route{required_params: params} = route) do
    example_values = Enum.map(params, fn _ -> "1" end)

    "#{route.name}(#{Enum.join(example_values, ", ")}) // => #{example_path(route, example_values)}"
  end

  defp example_path(route, values) do
    # Build path by replacing each parameter
    path =
      route.required_params
      |> Enum.with_index()
      |> Enum.reduce(route.path, fn {param, idx}, acc ->
        value = Enum.at(values, idx, "1") || "1"
        String.replace(acc, ":#{param}", to_string(value))
      end)

    # Remove optional segments
    path
    |> String.replace(~r/\([^)]*\)/, "")
  end

  defp generate_route_helper(route, params, spec, absolute) do
    params_js = inspect_js_object(params)
    spec_js = inspect_js(spec)

    case route do
      %Route{name: name} ->
        """
        const #{name} = /*#__PURE__*/ _builder.route(
          #{params_js},
          #{spec_js},
          #{absolute}
        );
        """
        |> String.trim()
    end
  end

  defp generate_exports(%Configuration{module_type: :esm}) do
    """
    // Configuration functions
    export const configure = (options) => _builder.configure(options);
    export const config = () => _builder.getConfig();
    """
  end

  defp generate_exports(%Configuration{module_type: :cjs}) do
    """
    // Configuration functions
    module.exports.configure = (options) => _builder.configure(options);
    module.exports.config = () => _builder.getConfig();
    """
  end

  defp generate_exports(%Configuration{module_type: :umd}) do
    # UMD exports both CommonJS and AMD style
    """
    // Configuration functions
    const configure = (options) => _builder.configure(options);
    const config = () => _builder.getConfig();

    if (typeof module !== 'undefined' && module.exports) {
      module.exports = { configure, config };
    } else if (typeof define === 'function' && define.amd) {
      define([], function() { return { configure, config }; });
    } else {
      this.Routes = this.Routes || {};
      this.Routes.configure = configure;
      this.Routes.config = config;
    }
    """
  end

  defp generate_exports(%Configuration{module_type: nil}) do
    # Global namespace
    """
    // Configuration functions
    window.Routes = window.Routes || {};
    window.Routes.configure = (options) => _builder.configure(options);
    window.Routes.config = () => _builder.getConfig();
    """
  end

  # Helper to convert Elixir data to JavaScript object notation
  defp inspect_js(data) when is_list(data) do
    items = Enum.map_join(data, ", ", &inspect_js/1)
    "[#{items}]"
  end

  defp inspect_js(data) when is_map(data) do
    inspect_js_object(data)
  end

  defp inspect_js(data) when is_binary(data) do
    # Escape quotes and wrap in quotes
    escaped = String.replace(data, "\"", "\\\"")
    "\"#{escaped}\""
  end

  defp inspect_js(data) when is_atom(data) do
    "\"#{data}\""
  end

  defp inspect_js(data) when is_number(data) or is_boolean(data) do
    to_string(data)
  end

  defp inspect_js(nil), do: "null"
  defp inspect_js(data), do: inspect(data)

  defp inspect_js_object(map) when is_map(map) do
    if map_size(map) == 0 do
      "{}"
    else
      pairs =
        map
        |> Enum.map(fn {k, v} ->
          key = if is_atom(k), do: Atom.to_string(k), else: k
          "#{key}: #{inspect_js(v)}"
        end)
        |> Enum.join(", ")

      "{ #{pairs} }"
    end
  end
end
