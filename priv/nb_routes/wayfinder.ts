/**
 * nb_routes Wayfinder Runtime
 *
 * Phoenix-idiomatic route helpers with type safety.
 * Generated by nb_routes - do not edit manually.
 */

export type Method = 'get' | 'post' | 'put' | 'patch' | 'delete' | 'head';

export interface Route<M extends Method = Method> {
  readonly url: string;
  readonly method: M;
}

export interface RouteOptions {
  query?: Record<string, string | number | boolean | null | undefined>;
  anchor?: string;
}

export interface FormAttrs {
  readonly action: string;
  readonly method: 'get' | 'post';
}

/** Acceptable parameter values - supports Phoenix.Param-style extraction */
export type Param = string | number | { id: string | number } | { [key: string]: unknown };

type RouteFunction<P, M extends Method> = {
  (params?: P, options?: RouteOptions): Route<M>;
  url: (params?: P, options?: RouteOptions) => string;
  get: (params?: P, options?: RouteOptions) => Route<'get'>;
  post: (params?: P, options?: RouteOptions) => Route<'post'>;
  patch: (params?: P, options?: RouteOptions) => Route<'patch'>;
  put: (params?: P, options?: RouteOptions) => Route<'put'>;
  delete: (params?: P, options?: RouteOptions) => Route<'delete'>;
  head: (params?: P, options?: RouteOptions) => Route<'head'>;
  form: FormFunction<P>;
  pattern: string;
  defaultMethod: M;
};

type FormFunction<P> = {
  (params?: P, options?: RouteOptions): FormAttrs;
  patch: (params?: P, options?: RouteOptions) => FormAttrs;
  put: (params?: P, options?: RouteOptions) => FormAttrs;
  delete: (params?: P, options?: RouteOptions) => FormAttrs;
};

/**
 * Creates a route helper function with method variants.
 *
 * @example
 * const show = route<{ id: Param }>('/users/:id', 'get');
 * show(1)           // { url: '/users/1', method: 'get' }
 * show({ id: 1 })   // { url: '/users/1', method: 'get' }
 * show(user)        // { url: '/users/42', method: 'get' } - extracts id
 * show.url(1)       // '/users/1'
 * show.patch(1)     // { url: '/users/1', method: 'patch' }
 */
export function route<P extends Record<string, Param> = Record<string, never>>(
  pattern: string,
  defaultMethod: Method
): RouteFunction<P extends Record<string, never> ? (P | Param | undefined) : (P | Param), typeof defaultMethod> {
  const buildUrl = (params?: P | Param, options?: RouteOptions): string => {
    let url = pattern;

    if (params != null) {
      const normalized = normalizeParams(pattern, params);
      for (const [key, value] of Object.entries(normalized)) {
        if (value != null) {
          url = url.replace(`:${key}`, encodeURIComponent(String(value)));
        }
      }
    }

    // Remove unfilled optional segments and clean up trailing slashes
    url = url.replace(/\(\/:[^)]+\)/g, '').replace(/\/+$/, '') || '/';

    // Handle query parameters
    if (options?.query) {
      const search = new URLSearchParams();
      for (const [k, v] of Object.entries(options.query)) {
        if (v != null) search.set(k, String(v));
      }
      const qs = search.toString();
      if (qs) url += '?' + qs;
    }

    // Handle anchor
    if (options?.anchor) url += '#' + options.anchor;

    return url;
  };

  const buildForm = (method: Method, params?: P | Param, options?: RouteOptions): FormAttrs => {
    const needsSpoof = method !== 'get' && method !== 'post';
    const url = buildUrl(params, needsSpoof
      ? { ...options, query: { ...options?.query, _method: method.toUpperCase() } }
      : options
    );
    return { action: url, method: needsSpoof ? 'post' : method as 'get' | 'post' };
  };

  const fn = (params?: P | Param, options?: RouteOptions): Route => ({
    url: buildUrl(params, options),
    method: defaultMethod,
  });

  fn.url = buildUrl;
  fn.get = (p?: P | Param, o?: RouteOptions) => ({ url: buildUrl(p, o), method: 'get' as const });
  fn.post = (p?: P | Param, o?: RouteOptions) => ({ url: buildUrl(p, o), method: 'post' as const });
  fn.patch = (p?: P | Param, o?: RouteOptions) => ({ url: buildUrl(p, o), method: 'patch' as const });
  fn.put = (p?: P | Param, o?: RouteOptions) => ({ url: buildUrl(p, o), method: 'put' as const });
  fn.delete = (p?: P | Param, o?: RouteOptions) => ({ url: buildUrl(p, o), method: 'delete' as const });
  fn.head = (p?: P | Param, o?: RouteOptions) => ({ url: buildUrl(p, o), method: 'head' as const });

  fn.form = Object.assign(
    (p?: P | Param, o?: RouteOptions) => buildForm(defaultMethod, p, o),
    {
      patch: (p?: P | Param, o?: RouteOptions) => buildForm('patch', p, o),
      put: (p?: P | Param, o?: RouteOptions) => buildForm('put', p, o),
      delete: (p?: P | Param, o?: RouteOptions) => buildForm('delete', p, o),
    }
  );

  fn.pattern = pattern;
  fn.defaultMethod = defaultMethod;

  return fn as RouteFunction<P extends Record<string, never> ? (P | Param | undefined) : (P | Param), typeof defaultMethod>;
}

/**
 * Normalizes parameters for URL building.
 * Supports Phoenix.Param-style extraction from objects.
 */
function normalizeParams(pattern: string, params: unknown): Record<string, unknown> {
  // Single primitive value - use for first (or only) param
  if (typeof params === 'string' || typeof params === 'number') {
    const match = pattern.match(/:(\w+)/);
    return { [match?.[1] ?? 'id']: params };
  }

  if (typeof params === 'object' && params !== null) {
    const obj = params as Record<string, unknown>;
    const result: Record<string, unknown> = {};
    const paramNames = pattern.match(/:\w+/g)?.map(p => p.slice(1)) ?? [];

    for (const name of paramNames) {
      if (name in obj) {
        const val = obj[name];
        // Support Phoenix.Param-style extraction: { id: 42 } or { user: { id: 42 } }
        result[name] = typeof val === 'object' && val && 'id' in val
          ? (val as { id: unknown }).id
          : val;
      } else if ('id' in obj && paramNames.length === 1) {
        // Single param route with object that has id - extract it
        result[name] = obj.id;
      }
    }
    return result;
  }

  return {};
}
